TITLE: Demo - Helmholtz equation on the unit sphere
AUTHOR: Mikael Mortensen {copyright|CC BY} Email:mikaem@math.uio.no at Department of Mathematics, University of Oslo.
DATE: today

__Summary.__
This is a demonstration of how the Python module "shenfun":
"https://github.com/spectralDNS/shenfun" can be used to solve the
Helmholtz equation on the surface of a unit sphere, using spherical
coordinates. This demo is implemented in
a single Python file "spherical_shell_helmholtz.py":
"https://github.com/spectralDNS/shenfun/blob/master/demo/spherical_shell_helmholtz.py".
If requested the solver will run in parallel using MPI.

FIGURE: [https://rawgit.com/spectralDNS/spectralutilities/master/figures/sphere.png, width=700 frac=1] Helmholtz on the unit sphere. label{fig:helmholtz}

TOC: on

<%
def mod(x):
    return '`'+x+'`'
def cls(x):
    return '`'+x+'`'
def func(x):
    return '`'+x+'`'
%>
% if FORMAT in ("sphinx"):
<%
def mod(x):
    if '.' in x:
        return ':mod:'+'`'+x+'`'
    return ':mod:'+'`'+'.'+x+'`'
def cls(x):
    if '.' in x:
        return ':class:'+'`'+x+'`'
    return ':class:'+'`'+'.'+x+'`'
def func(x):
    if '.' in x:
        return ':func:'+'`'+x+'`'
    return ':func:'+'`'+'.'+x+'`'
%>
% endif

======= Helmholtz equation =======
label{demo:spherical_helmholtz}

The Helmholtz equation is given as

!bt
\begin{align}
-\nabla^2 u(\bs{x}) + \alpha u(\bs{x}) &= f(\bs{x}) \quad \text{for }\, \bs{x} \in \Omega = \{(x, y, z): x^2+y^2+z^2 = 1\}, label{eq:helmholtz}\\
\end{align}
!et

where $u(\bs{x})$ is the solution, $f(\bs{x})$ is a function and $\alpha$ a constant.
We use spherical coordinates $(\theta, \phi)$, defined as

!bt
\begin{align}
 x &= r \sin \theta \cos \phi , \\
 y &= r \sin \theta \sin \phi, \\
 z &= r \cos \theta
\end{align}
!et

which (with $r=1$) leads to a 2D Cartesian product mesh $(\theta, \phi) \in (0, \pi) \times [0, 2\pi)$
suitable for numerical implementations. There are no boundary
conditions on the problem under consideration.
However, with the chosen Cartesian mesh, periodic
boundary conditions are required for the $\phi$-direction. As such,
the $\phi$-direction will use a Fourier basis $\exp(\imath k \phi)$.

A regular Chebyshev or Legendre basis
$\psi_j(\theta) = \gamma_j(2\theta/\pi-1)$ will be
used for the $\theta$-direction, where $\gamma_j$ could be either
the Chebyshev polynomial of first kind $T_j$ or the Legendre
polynomial $L_j$. Note the mapping from real coordinates $\theta$
to computational coordinates in domain $[-1, 1]$.

The spherical basis functions are as such

!bt
v_{jk}(\theta, \phi) = \psi_j(\theta) \exp(\imath k \phi),
!et

and we look for solutions

!bt
u(\theta, \phi) = \sum_{j} \sum_{k} \hat{u}_{jk} v_{jk}(\theta, \phi).
!et

A discrete Fourier approximation space with $N$ basis functions is then

!bt
V_F^N = \text{span} \{\exp(\imath k \theta)\}, \text{ for } k \in K,
!et

where $K = \{-N/2, -N/2+1, \ldots, N/2-1\}$. For this demo we assume
that the solution is complex, and as such there is no simplification
possible for Hermitian symmetry.

The following approximation space is used for the $\theta$-direction

!bt
\begin{align}
V^N &= \text{span} \{\psi_j\}_{j=0}^{N-1} \\
\end{align}
!et

and the variational formulation of the problem reads:
find $u \in V^N \otimes V_F^N$ such that
!bt
   \begin{equation}
   \int_{\Omega} (-\nabla^2 u + \alpha u) v w d\sigma = \int_{\Omega} f v w d\sigma, \quad \forall \, v \in V^N \otimes V_F^N.
   label{eq:u0}
   \end{equation}
!et

Note that integration over the domain is done using
spherical coordinates with an integral measure of $d\sigma=\sin \theta d\theta d\phi$.

======= Implementation in shenfun =======
label{demo:sphericalimplementation}

A complete implementation is found in the file "spherical_shell_helmholtz.py":
"https://github.com/spectralDNS/shenfun/blob/master/demo/spherical_shell_helmholtz.py".
Here we give a brief explanation for the implementation. Start by
importing all functionality from "shenfun":"https://github.com/spectralDNS/shenfun"
and "sympy":"https://sympy.org", where Sympy is required for handeling the
spherical coordinates.


!bc pycod
from shenfun import *
import sympy as sp

# Define spherical coordinates with unit radius
r = 1
theta, phi = sp.symbols('x,y', real=True, positive=True)
psi = (theta, phi)
rv = (r*sp.sin(theta)*sp.cos(phi), r*sp.sin(theta)*sp.sin(phi), r*sp.cos(theta))
!ec

Note that the position vector `rv` has three components (for $(x, y, z)$)
even though the computational domain is only 2D.
Also note that Sympy symbols are both positive and real, and $\theta$ is
chosen to be along the first axis and $\phi$ second. This has to agree with
the next step, which is the creation of tensorproductspaces
$V^N \otimes V_F^N$.

!bc pycod
N, M = 40, 30
L0 = Basis(N, 'C', domain=(0, np.pi))
F1 = Basis(M, 'F', dtype='D')
T = TensorProductSpace(comm, (L0, F1), coordinates=(psi, rv))

!ec

Spherical coordinates are ensured by feeding `coordinates=(psi, rv)`
to ${cls('TensorProductSpace')}. Operators like ${func('div')}
${func('grad')} and  ${func('curl')} will now work on
items of ${cls('Function')}, ${cls('TestFunction')} and
${cls('TrialFunction')} using a spherical coordinate system.

To define the equation (ref{eq:u0}) we first declare
these test- and trialfunctions, and then use code that
is very similar to the mathematics.

!bc pycod
alpha = 2
v = TestFunction(T)
u = TrialFunction(T)

mats = inner(v, -div(grad(u))+alpha*u)
!ec

Here `mats` will be a list containing several tensor product
matrices in the form of
${cls('TPMatrix')}. Since there is only one directions with
non-diagonal matrices ($\theta$-direction) we
can use the generic ${cls('SolverGeneric1NP')} solver.
Note that some of the non-diagonal matrices will be dense,
which is a weakness of the current method. Also note
that with Legendre one can use integration by parts
instead

!bc pycod
mats = inner(grad(v), grad(u))
mats += [inner(v, alpha*u)]
!ec

To solve the problem we also need to define the function $f(\theta, r)$.
To this end we use sympy and the method of
manufactured solution to define a possible solution `ue`,
and then compute `f` exactly using exact differentiation. We use
the "spherical harmonics function": "https://docs.sympy.org/latest/modules/functions/special.html#spherical-harmonics"
to define an analytical solution

!bc pycod

# Manufactured solution
alpha = 2
sph = sp.functions.special.spherical_harmonics.Ynm
ue = sph(6, 3, theta, phi)
f = - ue.diff(theta, 2) - (1/sp.tan(theta))*ue.diff(theta, 1) - (1/sp.sin(theta)**2)*ue.diff(phi, 2) + alpha*ue

# Compute the right hand side on the quadrature mesh
fj = Array(T, buffer=f)

# Take scalar product
f_hat = Function(T)
f_hat = inner(v, fj, output_array=f_hat)

u_hat = Function(T)
Sol = SolverGeneric1NP(mats)
u_hat = Sol(f_hat, u_hat)
!ec

Having found the solution in spectral space all that is
left is to transform it back to real space.

!bc pycod
uj = u_hat.backward()
uq = Array(T, buffer=ue)
print('Error =', np.linalg.norm(uj-uq))
!ec

Leading to
!bc pycod
Error = 8.383877617440085e-10
!ec

======= Postprocessing =======
We can refine the solution to make it look better,
and plot on the unit sphere using "mayavi":"https://docs.enthought.com/mayavi/mayavi/",
leading to Figure ref{fig:helmholtz}.

!bc
u_hat2 = u_hat.refine([N*2, M*2])
ur = u_hat2.backward()
from mayavi import mlab
xx, yy, zz = u_hat2.function_space().local_curvilinear_mesh()
# Wrap periodic direction around
if T.bases[1].domain == (0, 2*np.pi):
    xx = np.hstack([xx, xx[:, 0][:, None]])
    yy = np.hstack([yy, yy[:, 0][:, None]])
    zz = np.hstack([zz, zz[:, 0][:, None]])
    ur = np.hstack([ur, ur[:, 0][:, None]])
mlab.mesh(xx, yy, zz, scalars=ur.imag, colormap='jet')
mlab.show()
!ec


#======= Bibliography =======

## Publish (https://bitbucket.org/logg/publish is used to
## handle references. The line below specifies the name of
## the Publish database file (see the doconce manual for details).

% if FORMAT not in ("sphinx"):

BIBFILE: ../papers.pub

% else:


% endif
