TITLE: Demo - Kuramato-Sivashinsky equation 
AUTHOR: Mikael Mortensen {copyright|CC BY} Email:mikaem@math.uio.no at Department of Mathematics, University of Oslo.
DATE: today

__Summary.__
This is a demonstration of how the Python module "shenfun":
"https://github.com/spectralDNS/shenfun" can be used to solve the time-dependent,
nonlinear Kuramato-Sivashinsky equation, in a doubly periodic domain. The demo is implemented in
a single Python file "KuramatoSivashinsky.py":
"https://github.com/spectralDNS/shenfun/blob/master/demo/Kuramato_Sivashinsky.py", and it may be run
in parallel using MPI.

TOC: on

<%
def mod(x):
    return '`'+x+'`'
def cls(x):
    return '`'+x+'`'
def func(x):
    return '`'+x+'`'
%>
% if FORMAT in ("sphinx"):
<%
def mod(x):
    if '.' in x:
        return ':mod:'+'`'+x+'`'
    return ':mod:'+'`'+'.'+x+'`'
def cls(x):
    if '.' in x:
        return ':class:'+'`'+x+'`'
    return ':class:'+'`'+'.'+x+'`'
def func(x):
    if '.' in x:
        return ':func:'+'`'+x+'`'
    return ':func:'+'`'+'.'+x+'`'
%>
% endif

======= The Kuramato-Sivashinsky equation =======
% if FORMAT in ("latex", "pdflatex"):

FIGURE: [https://rawgit.com/spectralDNS/spectralutilities/master/figures/Kuramato_Sivashinsky_128_399.png] The solution $u$ from Eq. (ref{eq:ks}), at $t=100$.

% elif FORMAT in ("sphinx"):

MOVIE: [https://rawgit.com/spectralDNS/spectralutilities/master/movies/Kuramato_movie_128.gif]

Movie showing the evolution of the solution $u$ from Eq. (ref{eq:ks}).

% else:

MOVIE: [https://rawgit.com/spectralDNS/spectralutilities/master/movies/Kuramato_movie_128.gif] Movie showing the evolution of the solution $u$ from Eq. (ref{eq:ks}). 
% endif

===== Model equation =====

The Kuramato-Sivashinsky (KS) equation is known for its chaotic bahaviour, and it is
often used in study of turbulence or turbulent combustion. We will here solve
the KS equation in a doubly periodic domain $[-30\pi, 30\pi]^2$, starting from a
single Gaussian pulse
!bt
\begin{align}
\frac{\partial u(\bs{x},t)}{\partial t} &+ \nabla^2 u(\bs{x},t) + \nabla^4
u(\bs{x},t) + |\nabla u(\bs{x},t)|^2 = 0 \quad \text{for }\, \bs{x} \in \Omega=[-30 \pi, 30\pi]^2
label{eq:ks} \\
u(\bs{x}, 0) &= \exp(-0.01 \bs{x} \cdot \bs{x}) \notag
\end{align}
!et

===== Spectral Galerkin method =====

label{sec:spectralgalerkin}
The PDE in (ref{eq:ks}) can be solved with many different
numerical methods. We will here use the "shenfun":
"https://github.com/spectralDNS/shenfun" software and this software makes use of
the spectral Galerkin method. Being a Galerkin method, we need to reshape the
governing equations into proper variational forms, and this is done by
multiplying  (ref{eq:ks}) with the complex conjugate of a proper
test function and then integrating
over the domain. To this end we use testfunction $v\in H^1(\Omega)$, where $H^1(\Omega)$ is the Hilbert space, and we obtain

!bt
\begin{equation}
\frac{\partial}{\partial t} \int_{\Omega} u\, \overline{v} \,dx = -\int_{\Omega}
\left(\nabla^2 u + \nabla^4 u \ + |\nabla u|^2 \right) \overline{v} \,dx.
label{eq:du_var}
\end{equation}
!et
Note that the overline is used to indicate a complex conjugate. The function $u$
is now to be considered a trial function, and the integrals over the
domain are often referred to as inner products. With inner product notation

!bt
\[
\left(u, v\right) = \int_{\Omega} u \, \overline{v} \, dx.
\]
!et
the spatially discretized variational problem can be
formulated as: Find $u \in H^1(\Omega)$ such that
!bt
\begin{equation}
\frac{\partial}{\partial t} (u, v) = -\left(\nabla^2 u + \nabla^4 u + |\nabla u|^2,
v \right) \quad \forall v \in H^1(\Omega). label{eq:du_var2}
\end{equation}
!et 

The time discretization is
still left open. There are numerous different approaches that one could take for
discretizing in time. Here we will use a fourth order exponential Runge-Kutta
method.

===== Discretization =====

We discretize the model equation in space using Fourier basis functions

!bt
\begin{equation}
\phi_l(x) = e^{\imath \underline{l} x}, \quad -\infty < l < \infty,
\end{equation}
!et
where $l$ is the wavenumber, and $\underline{l}=\frac{2\pi}{L}l$ is the scaled wavenumber, scaled with domain
length $L$ (here $60\pi$). Since we want to solve these equations on a computer, we need to choose
a finite number of test functions. A basis $V^N$ can be defined as

!bt
\begin{equation}
V^N(x) = \text{span} \{\phi_l(x)\}_{l\in \boldsymbol{l}}, label{eq:Vn}
\end{equation}
!et
where $N$ is chosen as an even positive integer and $\boldsymbol{l} = (-N/2,
-N/2+1, \ldots, N/2-1)$. And now, since $\Omega$ is a
two-dimensional domain, we can create a Cartesian product of two such bases: 

!bt
\begin{equation}
W^{\boldsymbol{N}}(x, y) = V^N(x) \times V^N(y), label{eq:Wn}
\end{equation}
!et
where $\boldsymbol{N} = (N, N)$. Obviously, it is not necessary to use the
same number ($N$) of basis functions for each direction, but it is done here
for simplicity. A 2D tensor product basis function is now defined as

!bt
\begin{equation}
\Phi_{lm}(x,y) = e^{\imath \underline{l} x} e^{\imath \underline{m} y}
= e^{\imath (\underline{l}x + \underline{m}y )},
\end{equation}
!et
where the indices for $y$-direction are $\underline{m}=\frac{2\pi}{L}m$, and
$\bs{m}$ is the same set as $\bs{l}$ due to using the same number of basis functions for each direction. One
distinction, though, is that for the $y$-direction expansion coefficients are only stored for
$m=(0, 1, \ldots, N/2)$ due to Hermitian symmetry (real input data).

We now look for solutions of the form

!bt
\begin{equation}
u(x, y) = \sum_{l=-N/2}^{N/2-1}\sum_{m=-N/2}^{N/2-1}
\hat{u}_{lm} \Phi_{lm}(x,y). 
\end{equation}
!et

The expansion coefficients $\hat{u}_{lm}$ can be related directly to the solution $u(x,
y)$ using Fast Fourier Transforms (FFTs) if we are satisfied with obtaining
the solution in quadrature points corresponding to

!bt
\begin{align}
 x_i &= \frac{60 \pi i}{N}-30\pi \quad \forall \, i \in \boldsymbol{i},
\text{where}\, \boldsymbol{i}=(0,1,\ldots,N-1), \\
 y_j &= \frac{60 \pi j}{N}-30\pi \quad \forall \, j \in \boldsymbol{j},
\text{where}\, \boldsymbol{j}=(0,1,\ldots,N-1).
\end{align}
!et
Note that these points are different from the standard (like $2\pi j/N$) since
the domain
is set to $[-30\pi, 30\pi]^2$ and not the more common $[0, 2\pi]^2$. We now have

!bt
\begin{equation}
u(x_i, y_j) =
N^2
\mathcal{F}_y^{-1}\left(\mathcal{F}_x^{-1}\left(\hat{u}\right)\right)
\, \forall\, (i,j)\in\boldsymbol{i} \times \boldsymbol{j},
\end{equation}
!et
where $\mathcal{F}_x^{-1}$ is the inverse Fourier transform along direction
$x$, for all $j \in \boldsymbol{j} $. Note that the two
inverse FFTs are performed sequentially, one direction at the time, and that the
factor $N^2$ is due to
the definition used for the inverse Fourier transform, which is the one used
also by "Numpy": "https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.fft.html":

!bt
\begin{equation}
u(x_j) = \frac{1}{N}\sum_{l=-N/2}^{N/2-1} \hat{u}_l e^{\imath \underline{l}
x_j}, \quad \,\, \forall \, j \in \, \boldsymbol{j}.
\end{equation}
!et

The inner products used in Eq. (ref{eq:du_var2}) may be
computed using forward FFTs:

!bt
\begin{equation}
\left(u, \Phi_{lm}\right) =
\left(\frac{2\pi}{N}\right)^2
\mathcal{F}_l\left(\mathcal{F}_m\left({u}\right)\right)
\quad \forall (l,m) \in \boldsymbol{l} \times \boldsymbol{m},
\end{equation}
!et

whereas a complete transform requires
!bt
\begin{equation}
\hat{u}_{lm} =
\left(\frac{1}{N}\right)^2
\mathcal{F}_l\left(\mathcal{F}_m\left(u\right)\right)
\quad \forall (l,m) \in \boldsymbol{l} \times \boldsymbol{m}.
\end{equation}
!et

From this we see that the variational forms 
may be written in terms of the Fourier transformed $\hat{u}$. Expanding the
exact derivatives of the nabla operator, we have

!bt
\begin{align}
(\nabla^2 u, v) &=
-(2\pi)^2(\underline{l}^2+\underline{m}^2)\hat{u}_{l,m}, \\
(\nabla^4 u, v) &= (2\pi)^2(\underline{l}^2+\underline{m}^2)^2\hat{u}_{l,m}, \\
(|\nabla u|^2, v) &= (2\pi)^2 \widehat{|\nabla u|^2}
\end{align}
!et

and as such the equation to be solved can be found directly as

!bt
\begin{equation}
\frac{\partial \hat{u}}{\partial t}  =
\left(\underline{l}^2+\underline{m}^2 -
(\underline{l}^2+\underline{m}^2)^2\right)\hat{u} - \widehat{|\nabla u|^2},
label{eq:du_var3}
\end{equation}
!et


======= Implementation =======

The model equation (ref{eq:ks}) is implemented in shenfun using Fourier basis functions for
both $x$ and $y$ directions. We start the solver by implementing necessary
functionality from required modules like "Numpy": "https://numpy.org", "Sympy":"https://sympy.org"
"matplotlib":"https://matplotlib.org" and "mpi4py":"https://bitbucket.org/mpi4py", in
addition to "shenfun":"https://github.com/spectralDNS/shenfun": 
!bc pycod
from sympy import symbols, exp, lambdify
import numpy as np
import matplotlib.pyplot as plt
from mpi4py import MPI
from shenfun.fourier.bases import R2CBasis, C2CBasis
from shenfun import *
!ec

The size of the problem (in real space) is then specified, before creating
the ${cls('TensorProductSpace')}, which is a Cartesian product of two Fourier bases. We also
create a ${cls('VectorTensorProductSpace')}, since this is required for computing the
gradient of the scalar field `u`. The gradient is required for the nonlinear
term.
!bc pycod
# Size of discretization
N = (128, 128)

comm = MPI.COMM_WORLD
K0 = C2CBasis(N[0], domain=(-30*np.pi, 30*np.pi))
K1 = R2CBasis(N[1], domain=(-30*np.pi, 30*np.pi))
T = TensorProductSpace(comm, (K0, K1), **{'planner_effort': 'FFTW_MEASURE'})
TV = VectorTensorProductSpace([T, T])
!ec

Test and trialfunctions are required for assembling the variational forms:
!bc pycod
u = TrialFunction(T)
v = TestFunction(T)
!ec

and some arrays are required to hold the solution. We also create an array
`gradu`, that will be used to compute the gradient in the nonlinear term.
Finally, the wavenumbers are collected in list `K`. Here one feature is worth
mentioning. The gradient in spectral space can be computed as `1j*K*U_hat`.
However, since this is an odd derivative, and we are using an even number `N`
for the size of the domain, the highest wavenumber must be set to zero. This is
the purpose of the last keyword argument to `local_wavenumbers` below. 
!bc pycod
U = Array(T, False)
U_hat = Array(T)
gradu = Array(TV, False)
K = np.array(T.local_wavenumbers(True, True, eliminate_highest_freq=True))
!ec
Note that using this `K` in computing derivatives has the same effect as
achieved by symmetrizing the Fourier series by replacing the first sum below
with the second when computing odd derivatives.

!bt
\begin{align}
u & = \sum_{k=-N/2}^{N/2-1} \hat{u} \exp(\imath k x)\\
u & = \sideset{}{'}\sum_{k=-N/2}^{N/2} \hat{u} \exp(\imath k x)
\end{align}
!et
Here $\sideset{}{'}\sum$ means that the first and last items in the sum are
divided by two. Note that the two sums are equal as they stand (due to aliasing), but only the
latter (known as the Fourier interpolant) gives the correct (zero) derivative of
the basis with the highest wavenumber.  

Sympy is used to generate an initial condition, as stated in Eq (ref{eq:ks})
!bc pycod
# Use sympy to set up initial condition
x, y = symbols("x,y")
ue = exp(-0.01*(x**2+y**2))
ul = lambdify((x, y), ue, 'numpy')
!ec

Shenfun has a few integrators implemented in the ${mod('integrators')}
submodule. Two such integrators are the 4th order explicit Runge-Kutta method
`RK4`, and the exponential 4th order Runge-Kutta method `ETDRK4`. Both these
integrators need two methods provided by the problem being solved, representing
the linear and nonlinear terms in the problem equation. We define two methods
below, called `LinearRHS` and `NonlinearRHS`
!bc pycod
def LinearRHS():
    # Assemble diagonal bilinear forms
    A = inner(u, v)
    L = -(inner(div(grad(u)), v) + inner(div(grad(div(grad(u)))), v)) / A
    return L

def NonlinearRHS(U, U_hat, dU):
    # Assemble nonlinear term
    global gradu
    gradu = TV.backward(1j*K*U_hat, gradu)
    dU = T.forward(0.5*(gradu[0]*gradu[0]+gradu[1]*gradu[1]), dU)
    return dU
!ec
The code should, hopefully, be self-explanatory. 

All that remains now is to initialize the solution arrays and to setup the
integrator plus some plotting functionality for visualizing the results. Note
that visualization is only nice when running the code in serial. For parallel,
it is recommended to use ${cls('HDF5Writer')}, to store intermediate results to the HDF5
format, for later viewing in, e.g., Paraview. 

The solution is initialized as

!bc pycod
#initialize
X = T.local_mesh(True)
U[:] = ul(*X)
U_hat = T.forward(U, U_hat)
!ec

And we also create an update function for plotting intermediate results with a
cool colormap: 
!bc pycod
# Integrate using an exponential time integrator
plt.figure()
cm = plt.get_cmap('hot')
image = plt.contourf(X[0], X[1], U, 256, cmap=cm)
plt.draw()
plt.pause(1e-6)
count = 0
def update(u, u_hat, t, tstep, **params):
    global count
    if tstep % params['plot_step'] == 0 and params['plot_step'] > 0:
        u = T.backward(u_hat, u)
        image.ax.clear()
        image.ax.contourf(X[0], X[1], U, 256, cmap=cm)
        plt.pause(1e-6)
        count += 1
        plt.savefig('Kuramato_Sivashinsky_N_{}_{}.png'.format(N[0], count))

!ec
Now all that remains is to create the integrator and call it

!bc pycod
if __name__ == '__main__':
    par = {'plot_step': 100}
    dt = 0.01
    end_time = 100
    integrator = ETDRK4(T, L=LinearRHS, N=NonlinearRHS, update=update, **par)
    #integrator = RK4(T, L=LinearRHS, N=NonlinearRHS, update=update, **par)
    integrator.setup(dt)
    U_hat = integrator.solve(U, U_hat, dt, (0, end_time))
!ec
